"""
冒泡排序算法的运作如下：
顺序表简单，序偶一用顺序表实现冒泡排序

比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。(排一次，总共需要比较(n-1)次，循环n-1次)
对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
针对所有的元素重复以上的步骤，除了最后一个。
持续每次对越来越少的元素重复上面的步骤（也是需要循环（n-1）次），直到没有任何一对数字需要比较

"""
def bubble_sort(alist):
    """冒泡排序"""
    n = len(alist)
    #控制班长从头走到尾这个循环需要执行多少次
    for j in range(n-1): #排序玩所有的元素，需要n-1次，
        #班长从头走到尾需要走多少次
        for i in range(n-1-j):  #，注意用下表去算次数。最后一个元素下标是n-1,重复n-1次，尾部下标在动态变化，所以不是每一次都走n-1次
            count = 0
            if alist[i] > alist[i+1]:
                alist[i], alist[i+1] = alist[i+1], alist[i]
                count += 1
        if 0 == count:   #说明没有进行交换，即走到中间的某一次时，前面的已经有序，就不需要再循环冒泡了，可以直接退出，完成排序
            return

if __name__ == '__main__':
    l = [1, 19, 74, 22, 33, 11, 43, 33]
    bubble_sort(l)
    print(l)